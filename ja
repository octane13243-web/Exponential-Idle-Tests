import { BigNumber, parseBigNumber } from "./api/BigNumber";
import { theory } from "./api/Theory";
import { FirstFreeCost, ExponentialCost } from "./api/Costs";
import { Utils } from "./api/Utils";

var id = "log_example";
var name = "Logarithmic Growth";
var description = "ρ grows with the log10 of c₁, starting at 2, first free upgrade.";
var authors = "Horchata";
var version = 1;
var releaseOrder = "1";

requiresGameVersion("1.4.33");

var currency;
var c1;
var rho = BigNumber.ZERO;
var dtMultiplier = BigNumber.ONE;

var milestone1;

var init = () => {
    currency = theory.createCurrency();

    // --- c₁ upgrade ---
    {
        let getDesc = (level) => "c_1 = " + (level + 2);
        c1 = theory.createUpgrade(0, currency, new FirstFreeCost(new ExponentialCost(2, Math.log2(2.5))));
        c1.getDescription = (level) => Utils.getMath(getDesc(c1.level));
        c1.getInfo = (amount) => Utils.getMathTo(getDesc(c1.level), getDesc(c1.level + amount));
    }

    // --- Milestone at 1000ρ ---
    milestone1 = theory.createMilestoneUpgrade(0, 1);
    milestone1.getDescription = (_) => "Reach ρ ≥ 1000";
    milestone1.getInfo = (_) => "Milestone achieved at ρ ≥ 1000";
    milestone1.canBeRefunded = (_) => false;
    milestone1.boughtOrRefunded = (_) => {};

    // --- Story chapter ---
    theory.createStoryChapter(0, "Logarithmic Beginnings",
        "ρ grows slowly at first with c₁'s log10 value. Buy c₁ to start growth!", 
        () => currency.value.sign > 0
    );
};

var tick = (elapsedTime, multiplier) => {
    let dt = BigNumber.from(elapsedTime).mul(BigNumber.from(multiplier));

    if(c1.level > 0){
        // compute log10 growth
        let c1val = c1.level + 2; // starts at 2
        let logValue = Math.log10(c1val) / 10; // JS number
        let delta = BigNumber.from(logValue).mul(dt);
        rho = rho.add(delta);
        currency.value = currency.value.add(delta);
    }

    // check milestone
    if(rho.gte(1000)) milestone1.level = 1;

    theory.invalidatePrimaryEquation();
};

var getPrimaryEquation = () => {
    theory.primaryEquationHeight = 50;
    return "\\dot{\\rho} = \\frac{\\log_{10}(c_1)}{10}";
};

var getPublicationMultiplier = (tau) => BigNumber.ONE;
var getPublicationMultiplierFormula = (symbol) => symbol + "^1";
var getTau = () => currency.value.pow(BigNumber.from(0.1));
var getCurrencyFromTau = (tau) => [tau.max(BigNumber.ONE).pow(10), currency.symbol];

var getInternalState = () => rho.toString();
var setInternalState = (state) => { rho = parseBigNumber(state); };
var postPublish = () => { rho = BigNumber.ZERO; c1.level = 1; };

init();
