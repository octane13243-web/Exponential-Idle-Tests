import { ExponentialCost, FirstFreeCost, CompositeCost } from "./api/Costs";
import { BigNumber, parseBigNumber } from "./api/BigNumber";
import { theory } from "./api/Theory";
import { Utils } from "./api/Utils";

// Theory metadata
var id = "complex_skeleton";
var name = "Complex Skeleton";
var description = "A BigNumber-safe EI skeleton with x1, x2, milestones, and perms.";
var authors = "YourName#0000";
var version = 1;
var releaseOrder = "1";

requiresGameVersion("1.4.33");

// Currency
var currency;

// Upgrades
var x1Upg, x2Upg;

// Permanent upgrades
var pubUpg, buyAllUpg, autoUpg;

// Milestones
var milestone1, milestone2;

// State
var rho_dot = BigNumber.ZERO;

// INIT FUNCTION
var init = () => {
    currency = theory.createCurrency();

    ///////////////////
    // Upgrades
    x1Upg = theory.createUpgrade(0, currency, new ExponentialCost(BigNumber.TEN, Math.log2(2)));
    x1Upg.getDescription = (_) => "x_1 = 2^{" + x1Upg.level + "}";
    x1Upg.getInfo = (amount) => "x_1 = 2^{" + (x1Upg.level + amount) + "}";

    x2Upg = theory.createUpgrade(1, currency, new ExponentialCost(BigNumber.TEN, Math.log2(2)));
    x2Upg.getDescription = (_) => "x_2 = 2^{" + x2Upg.level + "}";
    x2Upg.getInfo = (amount) => "x_2 = 2^{" + (x2Upg.level + amount) + "}";

    ///////////////////
    // Permanent upgrades
    pubUpg = theory.createPublicationUpgrade(0, currency, BigNumber.TEN.pow(8));
    buyAllUpg = theory.createBuyAllUpgrade(1, currency, BigNumber.TEN.pow(15));
    autoUpg = theory.createAutoBuyerUpgrade(2, currency, BigNumber.TEN.pow(25));

    ///////////////////
    // Milestones
    milestone1 = theory.createMilestoneUpgrade(0, 1);
    milestone1.getDescription = (_) => "Unlock first milestone effect";
    milestone1.getInfo = (_) => "Effect: x1 bonus applied";

    milestone2 = theory.createMilestoneUpgrade(1, 1);
    milestone2.getDescription = (_) => "Unlock second milestone effect";
    milestone2.getInfo = (_) => "Effect: x2 bonus applied";

    ///////////////////
    // Primary Equation
    theory.primaryEquationHeight = 40;
    theory.primaryEquationScale = 1.0;

    ///////////////////
    // Tick function
    theory.setTickFunction((elapsedTime, multiplier) => {
        let dt = BigNumber.from(elapsedTime).mul(BigNumber.from(multiplier));

        let x1val = BigNumber.TWO.pow(BigNumber.from(x1Upg.level));
        let x2val = BigNumber.TWO.pow(BigNumber.from(x2Upg.level));

        rho_dot = x1val.mul(x2val).mul(dt);

        currency.value = currency.value.add(rho_dot);

        theory.invalidatePrimaryEquation();
    });
};

///////////////////
// Primary Equation Display
var getPrimaryEquation = () => {
    return "\\dot{\\rho} = x_1 \\cdot x_2";
};

///////////////////
// Internal State for save/load
var getInternalState = () => "";
var setInternalState = (state) => {};

init();