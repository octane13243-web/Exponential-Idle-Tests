import { BigNumber } from "./api/BigNumber";
import { theory } from "./api/Theory";
import { ExponentialCost } from "./api/Costs";

let rho = BigNumber.ZERO;

// upgrades
let c1, c2;

theory.createCurrency();

theory.primaryEquation = "\\dot{\\rho} = \\log(1+\\rho)(1 + c_1)(1 + c_2)";
theory.secondaryEquation = "c_1 = 2^{x_1},\\; c_2 = 2^{x_2}";
theory.description = "A logarithmicâ€“product growth theory.";
theory.name = "Log Product Growth";

// ===== UPGRADES =====
c1 = theory.createUpgrade(0, new ExponentialCost(10, Math.log2(2)));
c1.getDescription = (_) => "c_1 = 2^{x_1}";
c1.getInfo = (_) => "Increases first product term";
c1.level = 0;

c2 = theory.createUpgrade(1, new ExponentialCost(100, Math.log2(2)));
c2.getDescription = (_) => "c_2 = 2^{x_2}";
c2.getInfo = (_) => "Increases second product term";
c2.level = 0;

// ===== TICK FUNCTION =====
theory.tick = (elapsedTime, multiplier) => {
    let dt = BigNumber.from(elapsedTime) * BigNumber.from(multiplier);

    let c1val = BigNumber.TWO.pow(c1.level);
    let c2val = BigNumber.TWO.pow(c2.level);

    let logTerm = BigNumber.from(Math.log(1 + rho.toNumber()));

    let rhoDot =
        logTerm *
        (BigNumber.ONE + c1val) *
        (BigNumber.ONE + c2val);

    rho += rhoDot * dt;
};

// ===== SAVE / LOAD =====
theory.getPrimaryEquation = () => theory.primaryEquation;
theory.getSecondaryEquation = () => theory.secondaryEquation;