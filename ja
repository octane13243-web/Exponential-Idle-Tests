// === BigNumber-safe skeleton tick function ===
var tick = (elapsedTime, multiplier) => {
  let dt = BigNumber.from(elapsedTime * multiplier); // time step
  let bonus = theory.publicationMultiplier; // pub multiplier

  // Base upgrade values
  let v1 = x1.level > 0 ? BigNumber.from(1 + 0.2 * x1.level) : BigNumber.ONE; // holomorphic factor
  let v2 = x2.level > 0 ? BigNumber.from(1 + 0.1 * x2.level) : BigNumber.ONE; // complex exp factor

  // q = main variable / currency for calculation
  let qSafe = currency.value.gt(BigNumber.ZERO) ? currency.value : BigNumber.ONE;

  // ===== Approximations =====
  // sin(q) ≈ q - q^3/6 + q^5/120
  let sinApprox = qSafe.sub(qSafe.pow(3).div(BigNumber.from(6))).add(qSafe.pow(5).div(BigNumber.from(120)));

  // ln(1 + q) ≈ log10(1 + q) * ln(10)
  let lnApprox = qSafe.add(BigNumber.ONE).log10().mul(BigNumber.from(Math.LN10));

  // Product factor placeholder (x3)
  let prodFactor = x3.level > 0 ? BigNumber.from(1 + 0.05 * x3.level) : BigNumber.ONE;

  // Series sum factor placeholder (x5)
  let seriesFactor = x5.level > 0 ? BigNumber.from(1 + 0.03 * x5.level) : BigNumber.ONE;

  // Integral factor placeholder (x4)
  let integralFactor = x4.level > 0 ? BigNumber.from(1 + 0.02 * x4.level) : BigNumber.ONE;

  // ===== Main rho_dot calculation =====
  rho_dot = v1.mul(v2).mul(sinApprox.add(lnApprox))
               .mul(prodFactor)
               .mul(seriesFactor)
               .mul(integralFactor);

  // Update currency
  currency.value = currency.value.add(rho_dot.mul(dt).mul(bonus));

  // Invalidate equation display if needed
  if(mainEquationPressed) theory.invalidatePrimaryEquation();
};
