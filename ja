// imports
import { theory } from "./api/Theory";
import { FirstFreeCost, ExponentialCost } from "./api/Costs";

// basic info
var id = "complex_rho_theory";
var name = "Complex ρ Theory";
var description = "ρ accumulates with upgrade c₁, publications, milestones, and auto-buyer.";
var authors = "Horchata";
var version = 1;

requiresGameVersion("1.4.33");

// variables
var currency;
var rho = 0;
var c1;

// milestone
var milestone1;

// init function
var init = () => {
  currency = theory.createCurrency();

  /////////////////////////
  // Upgrades
  c1 = theory.createUpgrade(0, currency, new FirstFreeCost(new ExponentialCost(2, Math.log2(2))));
  c1.getDescription = (level) => "c₁ = " + (2 ** level).toString();
  c1.getInfo = (level) => "c₁ = " + (2 ** level).toString();

  /////////////////////////
  // Permanent Upgrades
  theory.createPublicationUpgrade(0, currency, 1e8);
  theory.createBuyAllUpgrade(1, currency, 1e15);
  theory.createAutoBuyerUpgrade(2, currency, 1e25);

  /////////////////////////
  // Milestones
  milestone1 = theory.createMilestoneUpgrade(0, 1);
  milestone1.getDescription = (_) => "Unlock special bonus at 1000ρ";
  milestone1.getInfo = (_) => "Rewards unlocked";
  milestone1.canBeRefunded = (_) => false;

  updateAvailability();
};

// updates availability
var updateAvailability = () => {
  milestone1.isAvailable = rho >= 1000;
};

// tick function
var tick = (elapsedTime, multiplier) => {
  if (c1.level > 0) {
    let dt = elapsedTime * multiplier;
    rho += Math.log10(2 ** c1.level) * dt; // log base 10 of 2^level
    currency.value = rho;
  }
  updateAvailability();
};

// primary equation display
var getPrimaryEquation = () => {
  return "\\rho = \\log_{10}(c₁)";
};

// get internal state for save/load
var getInternalState = () => rho.toString();
var setInternalState = (state) => {
  rho = parseFloat(state);
  updateAvailability();
};

// initialization
init();
