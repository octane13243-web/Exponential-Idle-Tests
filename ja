// imports
import { theory } from "./api/Theory";
import { ExponentialCost, FirstFreeCost } from "./api/Costs";
import { BigNumber } from "./api/BigNumber";
import { Utils } from "./api/Utils";

var id = "complex_ρ_theory";
var name = "Complex ρ Theory";
var description = "A simple theory to accumulate ρ using upgrades c₁ and c₂, with publications, milestones, and auto-buyers.";
var authors = "Horchata";
var version = 1;

requiresGameVersion("1.4.33");

var currency;
var rho = { value: 0 };

// Upgrades
var c1, c2;

// Permanent upgrades
var permPub, permBuyAll, permAuto;

// Milestone
var milestone1;

// Init
var init = () => {
    currency = theory.createCurrency();

    // -------- Upgrades --------
    c1 = theory.createUpgrade(0, currency, new FirstFreeCost(new ExponentialCost(2, 2)));
    c1.getDescription = (level) => "c₁ = 2^" + level;
    c1.getInfo = (level) => "c₁ = 2^" + level;

    c2 = theory.createUpgrade(1, currency, new ExponentialCost(5, 2));
    c2.getDescription = (level) => "c₂ = 5^" + level;
    c2.getInfo = (level) => "c₂ = 5^" + level;

    // -------- Permanent Upgrades --------
    permPub = theory.createPublicationUpgrade(0, currency, 1e3);
    permBuyAll = theory.createBuyAllUpgrade(1, currency, 1e5);
    permAuto = theory.createAutoBuyerUpgrade(2, currency, 1e7);

    // -------- Milestone --------
    milestone1 = theory.createMilestoneUpgrade(0, 1);
    milestone1.getDescription = (_) => "Reach ρ ≥ 1000";
    milestone1.getInfo = (_) => "Unlocks bonus multiplier!";
    milestone1.boughtOrRefunded = (_) => {
        if (rho.value >= 1000) {
            // maybe boost rho gain
        }
    };
};

// -------- Tick Function --------
var tick = (elapsedTime, multiplier) => {
    let dt = elapsedTime * multiplier;

    if (c1.level > 0) {
        let c1val = Math.pow(2, c1.level);
        let delta = Math.log10(c1val) / 10 * dt;
        rho.value += delta;
        currency.value += delta;
    }

    if (c2.level > 0) {
        let c2val = Math.pow(5, c2.level);
        let delta = Math.log10(c2val) / 10 * dt;
        rho.value += delta;
        currency.value += delta;
    }

    theory.invalidatePrimaryEquation();
};

// -------- Primary Equation --------
var getPrimaryEquation = () => {
    theory.primaryEquationHeight = 40;
    return "ρ = log(c₁)/10 + log(c₂)/10";
};

// -------- Internal State --------
var getInternalState = () => "" + rho.value + " " + c1.level + " " + c2.level;
var setInternalState = (state) => {
    let values = state.split(" ");
    if (values.length > 0) rho.value = parseFloat(values[0]);
    if (values.length > 1) c1.level = parseInt(values[1]);
    if (values.length > 2) c2.level = parseInt(values[2]);
};

// Initialize
init();
