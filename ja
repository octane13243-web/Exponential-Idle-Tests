//////////////////////////////
// Custom Theory: Logarithmic Growth
//////////////////////////////

var currency;
var c1;
var rho = BigNumber.zero;

var pubUpgrade, buyAllUpgrade, autoUpgrade;
var milestone1;

var init = () => {
    currency = theory.createCurrency();

    // c₁ Upgrade (free first purchase)
    c1 = theory.createUpgrade(0, currency, new FirstFreeCost(new ExponentialCost(2, 2)));
    c1.getDescription = (level) => "c₁ = " + theory.format(level, 0);
    c1.getInfo = (level) => "c₁ = " + theory.format(level, 0);

    // Permanent Upgrades
    pubUpgrade = theory.createPublicationUpgrade(0, currency, 1000);
    buyAllUpgrade = theory.createBuyAllUpgrade(1, currency, 1e5);
    autoUpgrade = theory.createAutoBuyerUpgrade(2, currency, 1e7);

    // Milestone at 1000ρ
    milestone1 = theory.createMilestoneUpgrade(0, 1);
    milestone1.getDescription = (_) => "Unlock bonus at 1000ρ";
    milestone1.getInfo = (_) => "Rewards unlocked";
    milestone1.canBeRefunded = (_) => false;

    updateAvailability();
};

var tick = (elapsedTime, multiplier) => {
    let dt = BigNumber.from(elapsedTime).mul(BigNumber.from(multiplier));

    if (c1.level > 0) {
        // ρ = 2 * log(c₁)/5 * dt using theory helpers
        let logc = c1.level.log10(); // log10(c1 level)
        let delta = logc.mul(2).div(5).mul(dt);
        rho = rho.add(delta);
        currency.value = rho;
    }

    // Auto-buy logic
    if (autoUpgrade.level > 0) {
        while (currency.value.gte(c1.getNextCost())) {
            currency.value = currency.value.sub(c1.getNextCost());
            c1.level++;
        }
    }

    // Buy-all logic
    if (buyAllUpgrade.level > 0) {
        while (currency.value.gte(c1.getNextCost())) {
            currency.value = currency.value.sub(c1.getNextCost());
            c1.level++;
        }
    }

    updateAvailability();
};

var updateAvailability = () => {
    milestone1.isAvailable = rho.gte(1000);
};

var getPrimaryEquation = () => "\\rho = 2 \\cdot \\frac{\\log_{10}(c_1)}{5}";

var getInternalState = () => rho;
var setInternalState = (state) => {
    rho = state;
    updateAvailability();
};

init();
